package gr.ml.analytics.service

import java.util.concurrent.atomic.AtomicInteger

import com.typesafe.scalalogging.LazyLogging
import gr.ml.analytics.cassandra.InputDatabase
import gr.ml.analytics.domain.Schema
import org.json4s.{DefaultFormats, Formats}

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future

class SchemaServiceImpl(inputDatabase: InputDatabase) extends SchemaService with LazyLogging {

  private lazy val schemasModel = inputDatabase.schemasModel

  private val idCounter: AtomicInteger = new AtomicInteger(0)

  implicit val jsonFormats: Formats = DefaultFormats

  override def get(id: Int): Future[String] = {
    schemasModel.getOne(id).map {
      case Some(schema) => schema.jsonSchema
      case None => ""
    }
  }

  override def save(jsonSchema: String): Int = {

    val objectSchema = Util.schemaToMap(jsonSchema)

    val normalizedStringSchema = Util.schemaToString(objectSchema)

    logger.info(s"Saving $normalizedStringSchema")

    // TODO should be generated by Cassandra
    val schemaId = idCounter.getAndIncrement()

    schemasModel.save(Schema(schemaId, normalizedStringSchema))

    val tableName = Util.itemsTableName(schemaId)

    // create cassandra table for items
    val (pkColumnName, pkColumnType) = Util.extractIdMetadata(objectSchema)
    val featureColumnsInfo: List[Map[String, String]] = Util.extractFeaturesMetadata(objectSchema)

    val columnsString: String = featureColumnsInfo
      .map(feature => (feature("name"), feature("type")))
      .foldLeft("") { (s: String, pair: (String, String)) =>
        s + " ," + pair._1 + " " + pair._2
      }

    val q = s"CREATE TABLE ${schemasModel.keySpace}.$tableName ($pkColumnName $pkColumnType PRIMARY KEY $columnsString )"

    logger.info(s"Creating: $q")
    schemasModel.session.execute(q).getColumnDefinitions
    schemaId
  }
}
